/**
   Python.d + D symbols instead of C macros
   Nothing here is @nogc nothrow because of the datetime API and the fact
   that it's in a struct and won't recurse.
 */
module python.raw;


#include "Python.h"
#include "datetime.h"
#include "structmember.h"
#include "enumobject.h"
#include "abstract.h"


/**
    All of the enum cases are macros instead of values in an enum
    so we make them available to D code with MethodArgs instead.
*/
enum MethodArgs {
    Var = METH_VARARGS,
    Keywords = METH_KEYWORDS,
    Static = METH_STATIC,
    None = METH_NOARGS,
    O = METH_O,
}

enum MemberType {
    Short = T_SHORT,
    Int = T_INT,
    Long = T_LONG,
    Float = T_FLOAT,
    Double = T_DOUBLE,
    String = T_STRING,
    Object = T_OBJECT,
    ObjectEx = T_OBJECT_EX,
    Char = T_CHAR,
    Byte = T_BYTE,
    UByte = T_UBYTE,
    UInt = T_UINT,
    UShort = T_USHORT,
    ULong = T_ULONG,
    Bool = T_BOOL,
    LongLong = T_LONGLONG,
    ULongLong = T_ULONGLONG,
    PySSizeT = T_PYSSIZET,
}

enum TypeFlags {
    BaseType = Py_TPFLAGS_BASETYPE,
    Default = Py_TPFLAGS_DEFAULT,
}


// Demacroify
mixin template PyObjectHead() {
    import python.raw: PyObject, Py_ssize_t;
    PyObject_HEAD;
}


auto pyTrue() {
    // This doesn't work as a manifest constant because there's a cast that the CTFE
    // engine doesn't like
    return Py_True;
}

// Demacroify
auto pyFalse() {
    // This doesn't work as a manifest constant because there's a cast that the CTFE
    // engine doesn't like
    return Py_False;
}

auto pyObjectNew(T)(PyTypeObject* typeobj) {
    return cast(T*) _PyObject_New(typeobj);
}

// Demacroify
// This fails due to some weird is(typeof) check for the date time capsule
void pyDateTimeImport() @nogc nothrow {
    PyDateTime_IMPORT;
}


// static inline function in the header
static int PyType_HasFeature(PyTypeObject *type, ulong feature) @safe @nogc pure nothrow {
    ulong flags;
    flags = type.tp_flags;
    return (flags & feature) != 0;
}

// static inline function in the header
static int _Py_IS_TYPE(const PyObject *ob, const PyTypeObject *type) @safe @nogc pure nothrow {
    return ob.ob_type == type;
}

// the check is here since this doesn't exist in Python 3.8
static if(is(typeof(Py_IS_TYPE(null, null)))) {
    // copied from 3.10 object.h
    private int _PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) @trusted nothrow {
        return Py_IS_TYPE(ob, type) || PyType_IsSubtype(( ( cast( PyObject * ) ( ob ) ) . ob_type ), type);
    }
}
